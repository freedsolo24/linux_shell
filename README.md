# Linux_shell
```bash
# while IFS=' ' read -r -a line || [[ -n ${line[*]} ]]
# 这个line是一个数组, 变为数组后不会保留整行内容, line此时是数组不是字符串
# while         read line || [[ -n ${line} ]]
# 这个line是一个字符串
---
# ${arr[@]}	     展开所有元素，每个是独立参数
# ${arr[*]}	     展开所有元素为一个字符串（用空格拼接）, 想把数组拼成一个字符串
# "${arr[@]}"	  每个元素保留独立性（推荐用于 for 等）,想逐个处理数组元素
# "${arr[*]}"	  所有元素拼成一个字符串，只有一个参数
```
## 001. 打印文本文件的行数
1. 通过while true 读取每一行
2. 读完一行变量加1，最后打印变量的值就是行数
  * 注意
    read读取每一行是以\n为分隔符, 如果文件最后一行没有\n, shell不认为这是一行,所以while read不会触发最后一次循环.
  * 解决方法
    ```while IFS= read -r line || [[ -n $line ]]```
    如果是最后一行 read读取不成功, 执行 [[ -n $line ]]
    $line仍保留最后一行, 判断$line非空为真, 就进入循环
## 002. 打印文本文件的最后5行
1. 先计算文本文件多少行
2. 上来判断倒数的行数，为真打印，判断之后减1
## 003. 输出0到500中7的倍数
1. for range循环，从0到500
2. 用变量i%7==0打印
## 004. 输出第5行
1. 声明控制变量i
2. while 读取文本文件，判断i=5，打印行内容。否则i++
## 005. 输出文件的空行行号
1. 声明控制行号的变量
2. while循环读取文件的每一行
3. 判断每一行是否“空”，YES打印行号，NO控制变量加1，继续循环
## 006. 去掉空行
1. while循环读取文件的每一行
2. 比较判断如果匹配空行，则删除这一行，如何做到删除这一行？
   * 如果匹配空行中止本趟循环，如果不是空行就打印出来
3. 比较的左边必须有双引号代表是字符串
## 007.打印每行中小于8个字母的单词
1. while循环读每一行
2. 在for循环遍历每一行，把每一行的“空格”替换成“换行”，相当于for遍历每个单词
   * 只能这么写：echo ${LINE} | tr ' ' '\n' 
   * 不能写成：  tr ' ' '\' ${LINE}  
3. if判断每个单词的字母小于8，打印
   * 写成这样： echo ${I} | wc -L
   * 不能写成： wc -L ${I}
### 008.统计文本中所有进程占内存比
1. 通过awk截取第6列,赋值给一个变量, 变量的本质是字符串
2. for循环这个变量,把所有的值相加
### 009.统计每个单词出现的个数
1. 声明一个map变量
2. while 循环读取每一行, 让LINE变成数组变量
3. for   循环读取LINE数组中的每一个单词, 赋值给key,然后value+1
4. for 遍历map中的每一个key,打印key对应的value
* 注意1: map[${WORD}]没有初始值,不能用${map[${WORD}]}来取值
* 注意2: map中用 map{!map[@]}取key,
*               ${map[${key}]}取value
### 010.统计一个nowcoder文件，第二列是否有重复，如果有重复有几个，并且提取重复的列
* 思路
  1. while 读取文件的每一行，放到数组变量
  2. 判断把第二列的字符串放到map中的key，并且map的value+1
  3. 此时已经把第二列放到了map中，map的key是第二列，map的value是第二列有几个
  4. 这个时候可以遍历这个map进行测试
  5. 遍历这个map,打印value>=2的,把对应的key和value打印出来
### 011. 转置文件内容
* 思路
  1. declare 2个数组
  2. while 读取每一行, 读到一个数组arr里
  3. arr[0]是第一列, 存到arr1数组里, 数组的索引通过长度来取
     arr[1]是第二列, 存到arr2数组里, 数组的索引通过长度来取
  4. 打印arr1, arr2
### 012. 统计文本文件中, 每一行出现的1~5数字的个数, 并且计算一下整个文档中一共出现了几个1~5数字的总数
* 思路
  1. 声明1个变量, 计算行数
  2. 声明一个哈希表, key是第几行,value计算每一行[1-5]数字出现的次数
  3. while 读取文本文件的每一行, 读到LINE中, LINE是一个字符串
  4. 用字符串取值，一个字符一个字符遍历，正则匹配[1-5]，匹配了就map的value+1
  5. 最后遍历打印map
### 013. 去掉输入文本中含有this的行, 把不含this的语句输出
* 思路
   1. while读取每一行, 声明每一行的变量LINE是一个array
   2. 声明一个has_this变量=0
   3. for遍历数组, 如果有this单词, has_this=1 并且 退出for循环
   4. 判断当has_this=0的时候, 打印此时的行
   * 注意
      (1) read -a line  把line变量变成数组, 变为数组后不会保留整行内容, line此时是数组不是字符串
      (2)  如果打印${line}, 实际输出的是$line[0], 也就是数组的第一个单词,要打印一行就得用${line[*]}
### 014. 求平均值
    第1行为输入数组的长度, 第2~n行是数组的元素, 如下:
    数组长度为4, 数组元素为1 2 9 8
    4
    1
    2
    9
    8
    并且要求打印的平均数保留两位小数点
* 思路
    1. 声明几个变量
      (1) var1 记录当前读的行是第一行吗
      (2) var2 记录这个文本一共有几个数
      (3) var3 记录总和
    2. while读取文本, 首先判断是不是第一行, 如果是第一行, 读到的数就是一共有几个数字
    3. 如果不是第一行, 就要做累加
    4. 最后退出循环, 使用bc做浮点计算
### 015. 去掉不需要的单词
    去掉输入中含有B和b的单词
    ```bash
    big
    nowcoder
    Betty
    basic
    test
    ```
* 思路
    1. while true 读取每一行，这个每一行是一个字符串
    2. 把读取到的每一行封装到数组里面  (${line})
    3. 遍历数组里的每一个单词, 正则匹配每个单词, 如果含有B|b就跳过, 不含有B|b就打印
    4. 匹配一个单词含有字母B或b, 一般正则要写成 ^.*[Bb].*$
       但是在shell里面用 [Bb] 就能匹配到, 因为shell中的regex是bre, 会尝试在整个字符串中寻找一处匹配即可成功.
       基本正则默认是在"任意位置查找是否存在这个模式"
### 016. 判断输入是否为ip地址
    判断每一行是否是正确的ip地址,如果正确输出yes,否则输出error
* 思路
    1. 读取每一行, 正则判断是不是ip地址
    2. 正则匹配ip地址
### 017. 将文本文件逆序输出, 字段之间用冒号:分隔
```bash
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh

/usr/bin/false:/var/empty:Unprivileged User:-2:-2:*:nobody
/bin/sh:/var/root:System Administrator:0:0:*:root
```
* 思路
  1. while true读取每一行
  2. awk判断每行有多少个字段
  3. 用cut和循环实现
     NF是冒号分割的字段, 从后往前拿, 第一次拿$NF, 打印之后加冒号:
     打印完之后, NF-1
     直到NF=1, 打印后面不加冒号
  4. 用数组实现
     声明一个数组
     awk求每行多少个字段
     进入循环, i>=1 && i<=nf ,进入循环
     通过cut拿第一个字段
     算出一个数组里面的最后一个索引号. 当前最后一个索引号
     在得出lastidx=6
     通过cut拿到第一个字段, 从后往前添加到数组, 判断如果是最后一个数组, 
     如果是最后一个索引,就不加+, 如果不是最后一个索引就加+
     数组里面是元素+空格,...元素+空格 的形式
     把数组封装到result里面, result就是一个字符串了
     然后再用字符串进行替换

### 018. 域名进行计数排序处理
```bash
http://www.nowcoder.com/index.html
http://www.nowcoder.com/1.html
http://m.nowcoder.com/index.html
```
* 思路
1. 遍历文件的每一行, 读取成一个字符串
2. 通过sed，或者字符串操作，只打印域名
3. 新建一个map
4. 把每一行放入map中的key，对应的value+1
5. 最后打印这个map，key就是域名，value就是有几个
6. 输出的结果用sort排序
