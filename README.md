# Linux_shell
## 001. 打印文本文件的行数
1. 通过while true 读取每一行
2. 读完一行变量加1，最后打印变量的值就是行数
## 002. 打印文本文件的最后5行
1. 先计算文本文件多少行
2. 上来判断倒数的行数，为真打印，判断之后减1
## 003. 输出0到500中7的倍数
1. for range循环，从0到500
2. 用变量i%7==0打印
## 004. 输出第5行
1. 声明控制变量i
2. while 读取文本文件，判断i=5，打印行内容。否则i++
## 005. 输出文件的空行行号
1. 声明控制行号的变量
2. while循环读取文件的每一行
3. 判断每一行是否“空”，YES打印行号，NO控制变量加1，继续循环
## 006. 去掉空行
1. while循环读取文件的每一行
2. 比较判断如果匹配空行，则删除这一行，如何做到删除这一行？
   * 如果匹配空行中止本趟循环，如果不是空行就打印出来
3. 比较的左边必须有双引号代表是字符串
## 007.打印每行中小于8个字母的单词
1. while循环读每一行
2. 在for循环遍历每一行，把每一行的“空格”替换成“换行”，相当于for遍历每个单词
   * 只能这么写：echo ${LINE} | tr ' ' '\n' 
   * 不能写成：  tr ' ' '\' ${LINE}  
3. if判断每个单词的字母小于8，打印
   * 写成这样： echo ${I} | wc -L
   * 不能写成： wc -L ${I}
### 008.统计文本中所有进程占内存比
1. 通过awk截取第6列,赋值给一个变量, 变量的本质是字符串
2. for循环这个变量,把所有的值相加
### 009.统计每个单词出现的个数
1. 声明一个map变量
2. while 循环读取每一行, 让LINE变成数组变量
3. for   循环读取LINE数组中的每一个单词, 赋值给key,然后value+1
4. for 遍历map中的每一个key,打印key对应的value
* 注意1: map[${WORD}]没有初始值,不能用${map[${WORD}]}来取值
* 注意2: map中用 map{!map[@]}取key,
*               ${map[${key}]}取value
### 010.统计一个nowcoder文件，第二列是否有重复，如果有重复有几个，并且提取重复的列
* 思路
  1. while 读取文件的每一行，放到数组变量
  2. 判断把第二列的字符串放到map中的key，并且map的value+1
  3. 此时已经把第二列放到了map中，map的key是第二列，map的value是第二列有几个
  4. 这个时候可以遍历这个map进行测试
  5. 遍历这个map,打印value>=2的,把对应的key和value打印出来
### 011. 转置文件内容
* 思路
  1. declare 2个数组
  2. while 读取每一行, 读到一个数组arr里
  3. arr[0]是第一列, 存到arr1数组里, 数组的索引通过长度来取
     arr[1]是第二列, 存到arr2数组里, 数组的索引通过长度来取
  4. 打印arr1, arr2
### 012. 统计文本文件中, 每一行出现的1~5数字的个数, 并且计算一下整个文档中一共出现了几个1~5数字的总数
* 思路
  1. 声明1个变量, 计算行数
  2. 声明一个哈希表, key是第几行,value计算每一行[1-5]数字出现的次数
  3. while 读取文本文件的每一行, 读到LINE中, LINE是一个字符串
  4. 用字符串取值，一个字符一个字符遍历，正则匹配[1-5]，匹配了就map的value+1
  5. 最后遍历打印map