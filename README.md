# Linux_shell
## 001. 打印文本文件的行数
1. 通过while true 读取每一行
2. 读完一行变量加1，最后打印变量的值就是行数
  * 注意
    read读取每一行是以\n为分隔符, 如果文件最后一行没有\n, shell不认为这是一行,所以while read不会触发最后一次循环.
  * 解决方法
    ```while IFS= read -r line || [[ -n $line ]]```
    如果是最后一行 read读取不成功, 执行 [[ -n $line ]]
    $line仍保留最后一行, 判断$line非空为真, 就进入循环
## 002. 打印文本文件的最后5行
1. 先计算文本文件多少行
2. 上来判断倒数的行数，为真打印，判断之后减1
## 003. 输出0到500中7的倍数
1. for range循环，从0到500
2. 用变量i%7==0打印
## 004. 输出第5行
1. 声明控制变量i
2. while 读取文本文件，判断i=5，打印行内容。否则i++
## 005. 输出文件的空行行号
1. 声明控制行号的变量
2. while循环读取文件的每一行
3. 判断每一行是否“空”，YES打印行号，NO控制变量加1，继续循环
## 006. 去掉空行
1. while循环读取文件的每一行
2. 比较判断如果匹配空行，则删除这一行，如何做到删除这一行？
   * 如果匹配空行中止本趟循环，如果不是空行就打印出来
3. 比较的左边必须有双引号代表是字符串
## 007.打印每行中小于8个字母的单词
1. while循环读每一行
2. 在for循环遍历每一行，把每一行的“空格”替换成“换行”，相当于for遍历每个单词
   * 只能这么写：echo ${LINE} | tr ' ' '\n' 
   * 不能写成：  tr ' ' '\' ${LINE}  
3. if判断每个单词的字母小于8，打印
   * 写成这样： echo ${I} | wc -L
   * 不能写成： wc -L ${I}
### 008.统计文本中所有进程占内存比
1. 通过awk截取第6列,赋值给一个变量, 变量的本质是字符串
2. for循环这个变量,把所有的值相加
### 009.统计每个单词出现的个数
1. 声明一个map变量
2. while 循环读取每一行, 让LINE变成数组变量
3. for   循环读取LINE数组中的每一个单词, 赋值给key,然后value+1
4. for 遍历map中的每一个key,打印key对应的value
* 注意1: map[${WORD}]没有初始值,不能用${map[${WORD}]}来取值
* 注意2: map中用 map{!map[@]}取key,
*               ${map[${key}]}取value
### 010.统计一个nowcoder文件，第二列是否有重复，如果有重复有几个，并且提取重复的列
* 思路
  1. while 读取文件的每一行，放到数组变量
  2. 判断把第二列的字符串放到map中的key，并且map的value+1
  3. 此时已经把第二列放到了map中，map的key是第二列，map的value是第二列有几个
  4. 这个时候可以遍历这个map进行测试
  5. 遍历这个map,打印value>=2的,把对应的key和value打印出来
### 011. 转置文件内容
* 思路
  1. declare 2个数组
  2. while 读取每一行, 读到一个数组arr里
  3. arr[0]是第一列, 存到arr1数组里, 数组的索引通过长度来取
     arr[1]是第二列, 存到arr2数组里, 数组的索引通过长度来取
  4. 打印arr1, arr2
### 012. 统计文本文件中, 每一行出现的1~5数字的个数, 并且计算一下整个文档中一共出现了几个1~5数字的总数
* 思路
  1. 声明1个变量, 计算行数
  2. 声明一个哈希表, key是第几行,value计算每一行[1-5]数字出现的次数
  3. while 读取文本文件的每一行, 读到LINE中, LINE是一个字符串
  4. 用字符串取值，一个字符一个字符遍历，正则匹配[1-5]，匹配了就map的value+1
  5. 最后遍历打印map
### 013. 去掉输入文本中含有this的行, 把不含this的语句输出
* 思路
   1. while读取每一行, 声明每一行的变量LINE是一个array
   2. 声明一个has_this变量=0
   3. for遍历数组, 如果有this单词, has_this=1 并且 退出for循环
   4. 判断当has_this=0的时候, 打印此时的行
   * 注意
      (1) read -a line  把line变量变成数组, 变为数组后不会保留整行内容, line此时是数组不是字符串
      (2)  如果打印${line}, 实际输出的是$line[0], 也就是数组的第一个单词,要打印一行就得用${line[*]}
